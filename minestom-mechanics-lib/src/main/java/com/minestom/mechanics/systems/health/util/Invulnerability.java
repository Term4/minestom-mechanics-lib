package com.minestom.mechanics.systems.health.util;

import com.minestom.mechanics.systems.health.HealthConfig;
import com.minestom.mechanics.systems.health.HealthSystem;
import com.minestom.mechanics.systems.health.tags.InvulnerabilityTagValue;
import com.minestom.mechanics.util.LogUtil;
import net.minestom.server.entity.Entity;
import net.minestom.server.entity.LivingEntity;
import net.minestom.server.entity.Player;
import org.jetbrains.annotations.Nullable;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Tracks invulnerability periods and damage replacement logic.
 * Handles i-frames and damage replacement for competitive gameplay.
 * Uses tag system for runtime configuration.
 */
public class Invulnerability {
    private static final LogUtil.SystemLogger log = LogUtil.system("InvulnerabilityTracker");
    
    private final HealthConfig config;
    private final Map<UUID, Long> lastDamageTick = new ConcurrentHashMap<>();
    private final Map<UUID, Float> lastDamageAmount = new ConcurrentHashMap<>();
    private final Map<UUID, Boolean> wasReplacement = new ConcurrentHashMap<>();
    private final Map<UUID, Long> lastProcessedTick = new ConcurrentHashMap<>();
    private long currentTick = 0;

    public Invulnerability(HealthConfig config) {
        this.config = config;
    }
    
    /**
     * Resolve invulnerability tag value with priority: item > attacker > player > world > server default
     * For environmental damage, uses: item > victim > world > server default
     */
    private InvulnerabilityTagValue resolveTag(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        // Use ConfigurableSystem pattern for tag resolution
        // We need to check: item > attacker > player > victim > world > server default
        com.minestom.mechanics.systems.health.tags.InvulnerabilityTagWrapper wrapper;
        net.minestom.server.tag.Tag<com.minestom.mechanics.systems.health.tags.InvulnerabilityTagWrapper> tag = HealthSystem.INVULNERABILITY;
        
        // 1. Check item FIRST (highest priority)
        if (item != null && !item.isAir()) {
            wrapper = item.getTag(tag);
            if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
        }
        
        // 2. Check attacker entity (if attacker exists)
        if (attacker != null) {
            wrapper = attacker.getTag(tag);
            if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
            
            // 3. Check player (if attacker is player)
            if (attacker instanceof net.minestom.server.entity.Player p) {
                wrapper = p.getTag(tag);
                if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
            }
        }
        
        // 4. Check victim entity (for environmental damage)
        wrapper = victim.getTag(tag);
        if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
        
        // 5. Check world
        if (victim.getInstance() != null) {
            wrapper = victim.getInstance().getTag(tag);
            if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
        }
        
        // 6. Server default
        return null;
    }
    
    /**
     * Convenience method for environmental damage (no attacker/item)
     */
    private InvulnerabilityTagValue resolveTag(LivingEntity entity) {
        return resolveTag(null, entity, null);
    }
    
    /**
     * Get invulnerability ticks for an entity (from tag or config)
     * Supports item > attacker > player > victim > world > server priority
     */
    private int getInvulnerabilityTicks(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tagValue = resolveTag(attacker, victim, item);
        if (tagValue != null && tagValue.invulnerabilityTicks() != null) {
            return tagValue.invulnerabilityTicks();
        }
        return config.getInvulnerabilityTicks();
    }
    
    /**
     * Convenience method for environmental damage
     */
    private int getInvulnerabilityTicks(LivingEntity entity) {
        return getInvulnerabilityTicks(null, entity, null);
    }
    
    /**
     * Check if damage replacement is enabled for an entity (from tag or config)
     * Supports item > attacker > player > victim > world > server priority
     */
    private boolean isDamageReplacementEnabled(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tagValue = resolveTag(attacker, victim, item);
        if (tagValue != null && tagValue.damageReplacementEnabled() != null) {
            return tagValue.damageReplacementEnabled();
        }
        return config.isDamageReplacementEnabled();
    }
    
    /**
     * Convenience method for environmental damage
     */
    private boolean isDamageReplacementEnabled(LivingEntity entity) {
        return isDamageReplacementEnabled(null, entity, null);
    }
    
    /**
     * Check if knockback should be applied on replacement for an entity (from tag or config)
     * Supports item > attacker > player > victim > world > server priority
     */
    private boolean isKnockbackOnReplacement(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tagValue = resolveTag(attacker, victim, item);
        if (tagValue != null && tagValue.knockbackOnReplacement() != null) {
            return tagValue.knockbackOnReplacement();
        }
        return config.isKnockbackOnReplacement();
    }
    
    /**
     * Convenience method for environmental damage
     */
    private boolean isKnockbackOnReplacement(LivingEntity entity) {
        return isKnockbackOnReplacement(null, entity, null);
    }

    /**
     * Update the current tick counter
     */
    public void updateTick() {
        this.currentTick++;
    }

    /**
     * Check if an entity can take damage based on invulnerability rules
     */
    public boolean canTakeDamage(LivingEntity entity, float incomingDamage) {
        UUID entityId = entity.getUuid();
        
        // Check for duplicate processing in the same tick
        Long lastProcessed = lastProcessedTick.get(entityId);
        if (lastProcessed != null && lastProcessed == currentTick) {
            log.debug("{} damage rejected (duplicate in same tick): {:.1f}",
                    getEntityName(entity), incomingDamage);
            return false;
        }
        
        Long lastDamage = lastDamageTick.get(entityId);
        if (lastDamage == null) {
            wasReplacement.put(entityId, false);  // NOT a replacement
            lastProcessedTick.put(entityId, currentTick);
            return true;
        }

        int invulnTicks = getInvulnerabilityTicks(null, entity, null);
        long ticksSinceLastDamage = currentTick - lastDamage;
        boolean isInIFrames = ticksSinceLastDamage < invulnTicks;
        
        // Debug logging
        if (config.isLogReplacementDamage()) {
            log.debug("{} invulnerability check: currentTick={}, lastDamage={}, ticksSince={}, invulnTicks={}, isInIFrames={}",
                    getEntityName(entity), currentTick, lastDamage, ticksSinceLastDamage, 
                    invulnTicks, isInIFrames);
        }

        if (!isInIFrames) {
            wasReplacement.put(entityId, false);  // NOT a replacement
            lastProcessedTick.put(entityId, currentTick);
            return true;
        }

        // Inside i-frame window
        if (isDamageReplacementEnabled(null, entity, null)) {
            Float previousDamage = lastDamageAmount.get(entityId);
            if (previousDamage == null) {
                wasReplacement.put(entityId, false);
                lastProcessedTick.put(entityId, currentTick);
                return false;
            }

            if (incomingDamage > previousDamage) {
                // REPLACEMENT HIT
                wasReplacement.put(entityId, true);  // THIS IS A REPLACEMENT
                lastProcessedTick.put(entityId, currentTick);
                if (config.isLogReplacementDamage()) {
                    log.debug("{} damage replacement: {} -> {} ({}/{} ticks)",
                            getEntityName(entity),
                            String.format("%.1f", previousDamage),
                            String.format("%.1f", incomingDamage),
                            ticksSinceLastDamage,
                            invulnTicks);
                }
                return true;
            } else {
                wasReplacement.put(entityId, false);
                lastProcessedTick.put(entityId, currentTick);
                if (config.isLogReplacementDamage()) {
                    log.debug("{} damage rejected (weaker): {} <= {} ({}/{} ticks)",
                            getEntityName(entity),
                            String.format("%.1f", incomingDamage),
                            String.format("%.1f", previousDamage),
                            ticksSinceLastDamage,
                            invulnTicks);
                }
                return false;
            }
        } else {
            wasReplacement.put(entityId, false);
            lastProcessedTick.put(entityId, currentTick);
            if (config.isLogReplacementDamage()) {
                log.debug("{} is invulnerable ({}/{} ticks)",
                        getEntityName(entity),
                        ticksSinceLastDamage,
                        config.getInvulnerabilityTicks());
            }
            return false;
        }
    }

    /**
     * Set an entity as invulnerable after taking damage
     */
    public void setInvulnerable(LivingEntity entity, float damageAmount) {
        lastDamageTick.put(entity.getUuid(), currentTick);
        lastDamageAmount.put(entity.getUuid(), damageAmount);

        if (config.getInvulnerabilityTicks() > 0 && config.isLogReplacementDamage()) {
            log.debug("{} now invulnerable for {} ticks (damage: {})",
                    getEntityName(entity),
                    config.getInvulnerabilityTicks(),
                    String.format("%.1f", damageAmount));
        }
    }
    
    /**
     * Update damage amount for replacement hits WITHOUT resetting invulnerability timer.
     * Used when a stronger hit lands during i-frames - we increase tracked damage but
     * don't give new i-frames (which would be exploitable).
     */
    public void updateDamageAmount(LivingEntity entity, float damageAmount) {
        lastDamageAmount.put(entity.getUuid(), damageAmount);
        if (config.isLogReplacementDamage()) {
            log.debug("{} damage amount updated to {} (no i-frame reset)",
                    getEntityName(entity),
                    String.format("%.1f", damageAmount));
        }
    }

    /**
     * Check if the last damage was a replacement hit
     */
    public boolean wasLastDamageReplacement(LivingEntity entity) {
        return wasReplacement.getOrDefault(entity.getUuid(), false);
    }

    /**
     * Get the last damage amount for an entity
     */
    public float getLastDamageAmount(LivingEntity entity) {
        return lastDamageAmount.getOrDefault(entity.getUuid(), 0f);
    }

    /**
     * Check if knockback should be applied for this entity
     */
    public boolean shouldApplyKnockback(LivingEntity entity) {
        boolean wasReplacementHit = wasLastDamageReplacement(entity);

        if (!wasReplacementHit) {
            return true;  // Normal hit, always apply knockback
        }

        // This was a replacement hit - check tag or config
        return isKnockbackOnReplacement(null, entity, null);
    }

    /**
     * Clean up tracking data for an entity
     */
    public void cleanup(LivingEntity entity) {
        UUID entityId = entity.getUuid();
        lastDamageTick.remove(entityId);
        lastDamageAmount.remove(entityId);
        wasReplacement.remove(entityId);
        lastProcessedTick.remove(entityId);
        if (entity instanceof Player player) {
            LogUtil.logCleanup("InvulnerabilityTracker", player.getUsername());
        }
    }

    /**
     * Clean up all tracking data
     */
    public void clearAll() {
        lastDamageTick.clear();
        lastDamageAmount.clear();
        wasReplacement.clear();
        lastProcessedTick.clear();
    }

    /**
     * Get the number of tracked entities
     */
    public int getTrackedEntities() {
        return lastDamageTick.size();
    }

    private String getEntityName(LivingEntity entity) {
        if (entity instanceof Player player) {
            return player.getUsername();
        }
        return entity.getClass().getSimpleName();
    }
}


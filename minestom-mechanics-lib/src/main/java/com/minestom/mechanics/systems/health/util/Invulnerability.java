package com.minestom.mechanics.systems.health.util;

import com.minestom.mechanics.config.health.HealthConfig;
import com.minestom.mechanics.systems.health.HealthSystem;
import com.minestom.mechanics.systems.health.tags.InvulnerabilityTagValue;
import com.minestom.mechanics.util.LogUtil;
import net.minestom.server.entity.Entity;
import net.minestom.server.entity.LivingEntity;
import net.minestom.server.entity.Player;
import org.jetbrains.annotations.Nullable;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Tracks invulnerability periods and damage replacement logic.
 * Handles i-frames and damage replacement for competitive gameplay.
 * Uses tag system for runtime configuration.
 */
public class Invulnerability {
    private static final LogUtil.SystemLogger log = LogUtil.system("InvulnerabilityTracker");

    private static Invulnerability instance;

    private final HealthConfig config;
    private final Map<UUID, Long> lastDamageTick = new ConcurrentHashMap<>();
    private final Map<UUID, Float> lastDamageAmount = new ConcurrentHashMap<>();
    private final Map<UUID, Boolean> wasReplacement = new ConcurrentHashMap<>();
    private long currentTick = 0;

    public Invulnerability(HealthConfig config) {
        this.config = config;
        instance = this;
    }

    /** Used by attack/knockback logic; may be null if HealthSystem has not initialized yet. */
    public static Invulnerability getInstance() {
        return instance;
    }
    
    /**
     * Resolve invulnerability tag value with priority: item > attacker > player > world > server default
     * For environmental damage, uses: item > victim > world > server default
     */
    private InvulnerabilityTagValue resolveTag(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        // Use ConfigurableSystem pattern for tag resolution
        // We need to check: item > attacker > player > victim > world > server default
        com.minestom.mechanics.systems.health.tags.InvulnerabilityTagWrapper wrapper;
        net.minestom.server.tag.Tag<com.minestom.mechanics.systems.health.tags.InvulnerabilityTagWrapper> tag = HealthSystem.INVULNERABILITY;
        
        // 1. Check item FIRST (highest priority)
        if (item != null && !item.isAir()) {
            wrapper = item.getTag(tag);
            if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
        }
        
        // 2. Check attacker entity (if attacker exists)
        if (attacker != null) {
            wrapper = attacker.getTag(tag);
            if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
            
            // 3. Check player (if attacker is player)
            if (attacker instanceof net.minestom.server.entity.Player p) {
                wrapper = p.getTag(tag);
                if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
            }
        }
        
        // 4. Check victim entity (for environmental damage)
        wrapper = victim.getTag(tag);
        if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
        
        // 5. Check world
        if (victim.getInstance() != null) {
            wrapper = victim.getInstance().getTag(tag);
            if (wrapper != null && wrapper.getCustom() != null) return wrapper.getCustom();
        }
        
        // 6. Server default
        return null;
    }
    
    /**
     * Convenience method for environmental damage (no attacker/item)
     */
    private InvulnerabilityTagValue resolveTag(LivingEntity entity) {
        return resolveTag(null, entity, null);
    }
    
    /**
     * Get invulnerability ticks for this hit context (from tag or config).
     * Supports item > attacker > player > victim > world > server priority.
     * Used by DamageApplicator to resolve i-frame duration and make replacement vs block decision.
     */
    public int getInvulnerabilityTicks(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tagValue = resolveTag(attacker, victim, item);
        if (tagValue != null && tagValue.invulnerabilityTicks() != null) {
            return tagValue.invulnerabilityTicks();
        }
        return config.getInvulnerabilityTicks();
    }

    /**
     * Check if damage replacement is enabled for this hit context (from tag or config).
     * Supports item > attacker > player > victim > world > server priority.
     */
    public boolean isDamageReplacementEnabled(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tagValue = resolveTag(attacker, victim, item);
        if (tagValue != null && tagValue.damageReplacementEnabled() != null) {
            return tagValue.damageReplacementEnabled();
        }
        return config.isDamageReplacementEnabled();
    }

    /**
     * Resolve invulnerability tag for the given context (e.g. for weapon bypass check).
     * Item > attacker > victim > world > server.
     */
    public InvulnerabilityTagValue resolveInvulnerabilityTag(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        return resolveTag(attacker, victim, item);
    }

    /**
     * Check if damage from this context bypasses creative mode invulnerability (so creative players can be damaged).
     * Used for projectiles and non-melee damage. Resolves tag: item > attacker > victim > world > server. Default false when unspecified.
     */
    public boolean isBypassCreativeInvulnerability(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tag = resolveTag(attacker, victim, item);
        return tag != null && Boolean.TRUE.equals(tag.bypassCreativeInvulnerability());
    }

    /**
     * Check if melee damage from this context bypasses creative mode invulnerability.
     * Only true when the resolved tag has bypassCreativeMelee set. Use this for player attack (PLAYER_ATTACK) damage.
     */
    public boolean isBypassCreativeInvulnerabilityMelee(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tag = resolveTag(attacker, victim, item);
        return tag != null && Boolean.TRUE.equals(tag.bypassCreativeMelee());
    }
    
    /**
     * Check if knockback should be applied on replacement for an entity (from tag or config)
     * Supports item > attacker > player > victim > world > server priority
     */
    private boolean isKnockbackOnReplacement(@Nullable Entity attacker, LivingEntity victim, @Nullable net.minestom.server.item.ItemStack item) {
        InvulnerabilityTagValue tagValue = resolveTag(attacker, victim, item);
        if (tagValue != null && tagValue.knockbackOnReplacement() != null) {
            return tagValue.knockbackOnReplacement();
        }
        return config.isKnockbackOnReplacement();
    }
    
    /**
     * Convenience method for environmental damage
     */
    private boolean isKnockbackOnReplacement(LivingEntity entity) {
        return isKnockbackOnReplacement(null, entity, null);
    }

    /**
     * Update the current tick counter
     */
    public void updateTick() {
        this.currentTick++;
    }

    /**
     * Ticks since the entity last took damage. Returns -1 if they have never been recorded as damaged.
     * Used by DamageApplicator to decide if the entity is in the i-frame window.
     */
    public long getTicksSinceLastDamage(LivingEntity entity) {
        Long last = lastDamageTick.get(entity.getUuid());
        if (last == null) return -1;
        return currentTick - last;
    }

    /**
     * Set whether the last damage to this entity was a replacement hit.
     * Called by DamageApplicator so that shouldApplyKnockback() works correctly.
     */
    public void setLastDamageReplacement(LivingEntity entity, boolean replacement) {
        wasReplacement.put(entity.getUuid(), replacement);
    }

    /**
     * Set an entity as invulnerable after taking damage
     */
    public void setInvulnerable(LivingEntity entity, float damageAmount) {
        lastDamageTick.put(entity.getUuid(), currentTick);
        lastDamageAmount.put(entity.getUuid(), damageAmount);

        if (config.getInvulnerabilityTicks() > 0 && config.isLogReplacementDamage()) {
            log.debug("{} now invulnerable for {} ticks (damage: {})",
                    getEntityName(entity),
                    config.getInvulnerabilityTicks(),
                    String.format("%.1f", damageAmount));
        }
    }
    
    /**
     * Update damage amount for replacement hits WITHOUT resetting invulnerability timer.
     * Used when a stronger hit lands during i-frames - we increase tracked damage but
     * don't give new i-frames (which would be exploitable).
     */
    public void updateDamageAmount(LivingEntity entity, float damageAmount) {
        lastDamageAmount.put(entity.getUuid(), damageAmount);
        if (config.isLogReplacementDamage()) {
            log.debug("{} damage amount updated to {} (no i-frame reset)",
                    getEntityName(entity),
                    String.format("%.1f", damageAmount));
        }
    }

    /**
     * Check if the last damage was a replacement hit
     */
    public boolean wasLastDamageReplacement(LivingEntity entity) {
        return wasReplacement.getOrDefault(entity.getUuid(), false);
    }

    /**
     * Get the last damage amount for an entity
     */
    public float getLastDamageAmount(LivingEntity entity) {
        return lastDamageAmount.getOrDefault(entity.getUuid(), 0f);
    }

    /**
     * Check if knockback should be applied for this entity
     */
    public boolean shouldApplyKnockback(LivingEntity entity) {
        boolean wasReplacementHit = wasLastDamageReplacement(entity);

        if (!wasReplacementHit) {
            return true;  // Normal hit, always apply knockback
        }

        // This was a replacement hit - check tag or config
        return isKnockbackOnReplacement(null, entity, null);
    }

    /**
     * Clean up tracking data for an entity
     */
    public void cleanup(LivingEntity entity) {
        UUID entityId = entity.getUuid();
        lastDamageTick.remove(entityId);
        lastDamageAmount.remove(entityId);
        wasReplacement.remove(entityId);
        if (entity instanceof Player player) {
            LogUtil.logCleanup("InvulnerabilityTracker", player.getUsername());
        }
    }

    /**
     * Clean up all tracking data
     */
    public void clearAll() {
        lastDamageTick.clear();
        lastDamageAmount.clear();
        wasReplacement.clear();
    }

    /**
     * Get the number of tracked entities
     */
    public int getTrackedEntities() {
        return lastDamageTick.size();
    }

    private String getEntityName(LivingEntity entity) {
        if (entity instanceof Player player) {
            return player.getUsername();
        }
        return entity.getClass().getSimpleName();
    }
}


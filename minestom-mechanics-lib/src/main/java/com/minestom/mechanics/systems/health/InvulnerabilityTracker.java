package com.minestom.mechanics.systems.health;

import com.minestom.mechanics.config.health.HealthConfig;
import com.minestom.mechanics.util.LogUtil;
import net.minestom.server.entity.LivingEntity;
import net.minestom.server.entity.Player;
import net.minestom.server.tag.Tag;

/**
 * Tracks invulnerability (i-frame) state per entity using {@code Tag.Transient}.
 * State lives on the entity itself -- no external maps, no manual cleanup needed.
 *
 * <p>This class only marks/unmarks invulnerability and tracks state during i-frames.
 * It never applies damage. Only the damage system (DamageApplicator) should access this.</p>
 */
public class InvulnerabilityTracker {
    private static final LogUtil.SystemLogger log = LogUtil.system("InvulnerabilityTracker");

    private record InvulnerabilityState(long lastDamageTick, float lastDamageAmount, boolean wasReplacement) {}
    private static final Tag<InvulnerabilityState> STATE = Tag.Transient("health_invuln_state");

    private final HealthConfig config;
    private long currentTick = 0;

    public InvulnerabilityTracker(HealthConfig config) {
        this.config = config;
    }

    // ===========================
    // TICK
    // ===========================

    /** Advance the internal tick counter. Called once per server tick by HealthSystem. */
    public void updateTick() { currentTick++; }

    // ===========================
    // STATE MANAGEMENT
    // ===========================

    /** Mark an entity as having taken damage, starting the i-frame window. */
    public void markDamaged(LivingEntity entity, float damageAmount) {
        entity.setTag(STATE, new InvulnerabilityState(currentTick, damageAmount, false));
        if (config.logDamage() && config.isInvulnerabilityEnabled()) {
            log.debug("{} now invulnerable for {} ticks (damage: {:.1f})",
                    getEntityName(entity), config.invulnerabilityTicks(), damageAmount);
        }
    }

    /** Update tracked damage amount for replacement WITHOUT resetting i-frame timer. */
    public void updateDamageAmount(LivingEntity entity, float damageAmount) {
        InvulnerabilityState state = entity.getTag(STATE);
        if (state != null) {
            entity.setTag(STATE, new InvulnerabilityState(state.lastDamageTick, damageAmount, state.wasReplacement));
        }
    }

    /** Set whether the last damage to this entity was a replacement hit. */
    public void setLastDamageReplacement(LivingEntity entity, boolean replacement) {
        InvulnerabilityState state = entity.getTag(STATE);
        if (state != null) {
            entity.setTag(STATE, new InvulnerabilityState(state.lastDamageTick, state.lastDamageAmount, replacement));
        }
    }

    // ===========================
    // QUERIES
    // ===========================

    /** Whether the entity is currently in the i-frame window. */
    public boolean isInvulnerable(LivingEntity entity) {
        if (!config.isInvulnerabilityEnabled()) return false;
        long ticksSince = getTicksSinceLastDamage(entity);
        return ticksSince >= 0 && ticksSince < config.invulnerabilityTicks();
    }

    /** Ticks since this entity last took damage. Returns -1 if never damaged. */
    public long getTicksSinceLastDamage(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null ? currentTick - state.lastDamageTick : -1;
    }

    /** Whether the last damage was a replacement hit. */
    public boolean wasLastDamageReplacement(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null && state.wasReplacement;
    }

    /** Get the last damage amount (for replacement calculation). */
    public float getLastDamageAmount(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null ? state.lastDamageAmount : 0f;
    }

    // ===========================
    // CLEANUP
    // ===========================

    /** Remove invulnerability state for an entity. */
    public void clearState(LivingEntity entity) {
        entity.removeTag(STATE);
    }

    private String getEntityName(LivingEntity entity) {
        if (entity instanceof Player player) return player.getUsername();
        return entity.getClass().getSimpleName();
    }
}

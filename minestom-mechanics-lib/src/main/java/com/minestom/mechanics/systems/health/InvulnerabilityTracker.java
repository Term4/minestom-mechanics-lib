package com.minestom.mechanics.systems.health;

import com.minestom.mechanics.config.health.HealthConfig;
import com.minestom.mechanics.util.LogUtil;
import net.minestom.server.entity.LivingEntity;
import net.minestom.server.entity.Player;
import net.minestom.server.item.ItemStack;
import net.minestom.server.tag.Tag;
import org.jetbrains.annotations.Nullable;

/**
 * Tracks invulnerability (i-frame) state per entity using {@code Tag.Transient}.
 * State lives on the entity itself -- no external maps, no manual cleanup needed.
 *
 * <p>This class only marks/unmarks invulnerability and tracks state during i-frames.
 * It never applies damage. Only the damage pipeline ({@link com.minestom.mechanics.systems.health.damage.DamageType#processDamage}) should access this.</p>
 */
public class InvulnerabilityTracker {
    private static final LogUtil.SystemLogger log = LogUtil.system("InvulnerabilityTracker");

    private record InvulnerabilityState(long lastDamageTick, float lastDamageAmount, boolean wasReplacement) {}
    private static final Tag<InvulnerabilityState> STATE = Tag.Transient("health_invuln_state");
    private static final Tag<ItemStack> LAST_MELEE_ITEM = Tag.Transient("health_last_melee_item");

    private final HealthConfig config;
    private long currentTick = 0;

    public InvulnerabilityTracker(HealthConfig config) {
        this.config = config;
    }

    // ===========================
    // TICK
    // ===========================

    /** Advance the internal tick counter. Called once per server tick by HealthSystem. */
    public void updateTick() { currentTick++; }

    // ===========================
    // STATE MANAGEMENT
    // ===========================

    /** Mark an entity as having taken damage, starting the i-frame window. */
    public void markDamaged(LivingEntity entity, float damageAmount) {
        markDamaged(entity, damageAmount, null);
    }

    /** Mark an entity as having taken damage. When item is non-null (melee), stores it for same-item replacement check. */
    public void markDamaged(LivingEntity entity, float damageAmount, @Nullable ItemStack item) {
        entity.setTag(STATE, new InvulnerabilityState(currentTick, damageAmount, false));
        if (item != null) {
            entity.setTag(LAST_MELEE_ITEM, item);
        } else {
            entity.removeTag(LAST_MELEE_ITEM);
        }
        if (config.logDamage() && config.isInvulnerabilityEnabled()) {
            log.debug("{} now invulnerable for {} ticks (damage: {:.1f})",
                    getEntityName(entity), config.invulnerabilityTicks(), damageAmount);
        }
    }

    /** Update tracked damage amount for replacement WITHOUT resetting i-frame timer. */
    public void updateDamageAmount(LivingEntity entity, float damageAmount) {
        InvulnerabilityState state = entity.getTag(STATE);
        if (state != null) {
            entity.setTag(STATE, new InvulnerabilityState(state.lastDamageTick, damageAmount, state.wasReplacement));
        }
    }

    /** Set whether the last damage to this entity was a replacement hit. */
    public void setLastDamageReplacement(LivingEntity entity, boolean replacement) {
        InvulnerabilityState state = entity.getTag(STATE);
        if (state != null) {
            entity.setTag(STATE, new InvulnerabilityState(state.lastDamageTick, state.lastDamageAmount, replacement));
        }
    }

    // ===========================
    // QUERIES
    // ===========================

    /** Whether the entity is currently in the i-frame window. */
    public boolean isInvulnerable(LivingEntity entity) {
        if (!config.isInvulnerabilityEnabled()) return false;
        long ticksSince = getTicksSinceLastDamage(entity);
        return ticksSince >= 0 && ticksSince < config.invulnerabilityTicks();
    }

    /** Ticks since this entity last took damage. Returns -1 if never damaged. */
    public long getTicksSinceLastDamage(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null ? currentTick - state.lastDamageTick : -1;
    }

    /** Tick when this entity last took damage. Returns -1 if never damaged. */
    public long getLastDamageTick(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null ? state.lastDamageTick : -1;
    }

    /** Whether the last damage was a replacement hit. */
    public boolean wasLastDamageReplacement(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null && state.wasReplacement;
    }

    /** Get the last damage amount (for replacement calculation). */
    public float getLastDamageAmount(LivingEntity entity) {
        InvulnerabilityState state = entity.getTag(STATE);
        return state != null ? state.lastDamageAmount : 0f;
    }

    /** Get the item used for the last melee damage to this entity. Null if last damage was not melee. */
    @Nullable
    public ItemStack getLastMeleeItem(LivingEntity entity) {
        return entity.getTag(LAST_MELEE_ITEM);
    }

    // ===========================
    // CLEANUP
    // ===========================

    /** Remove invulnerability state for an entity. */
    public void clearState(LivingEntity entity) {
        entity.removeTag(STATE);
        entity.removeTag(LAST_MELEE_ITEM);
    }

    private String getEntityName(LivingEntity entity) {
        if (entity instanceof Player player) return player.getUsername();
        return entity.getClass().getSimpleName();
    }
}

package com.minestom.mechanics.damage.components;

// TODO: I like this a lot, very functional. Just make sure it's thread and memory safe, also
//  could be good to split this up a bit for organization, and would make it easier
//  for users to interact with

import com.minestom.mechanics.util.LogUtil;
import com.minestom.mechanics.config.gameplay.DamageConfig;
import net.minestom.server.entity.LivingEntity;
import net.minestom.server.entity.Player;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Tracks invulnerability periods and damage replacement logic.
 * Handles i-frames and damage replacement for competitive gameplay.
 */
public class InvulnerabilityTracker {
    private static final LogUtil.SystemLogger log = LogUtil.system("InvulnerabilityTracker");
    
    private final DamageConfig config;
    private final Map<UUID, Long> lastDamageTick = new ConcurrentHashMap<>();
    private final Map<UUID, Float> lastDamageAmount = new ConcurrentHashMap<>();
    private final Map<UUID, Boolean> wasReplacement = new ConcurrentHashMap<>();
    private final Map<UUID, Long> lastProcessedTick = new ConcurrentHashMap<>();
    private long currentTick = 0;

    public InvulnerabilityTracker(DamageConfig config) {
        this.config = config;
    }

    /**
     * Update the current tick counter
     */
    public void updateTick() {
        this.currentTick++;
    }

    /**
     * Check if an entity can take damage based on invulnerability rules
     */
    public boolean canTakeDamage(LivingEntity entity, float incomingDamage) {
        UUID entityId = entity.getUuid();
        
        // Check for duplicate processing in the same tick
        Long lastProcessed = lastProcessedTick.get(entityId);
        if (lastProcessed != null && lastProcessed == currentTick) {
            log.debug("{} damage rejected (duplicate in same tick): {:.1f}",
                    getEntityName(entity), incomingDamage);
            return false;
        }
        
        Long lastDamage = lastDamageTick.get(entityId);
        if (lastDamage == null) {
            wasReplacement.put(entityId, false);  // NOT a replacement
            lastProcessedTick.put(entityId, currentTick);
            return true;
        }

        long ticksSinceLastDamage = currentTick - lastDamage;
        boolean isInIFrames = ticksSinceLastDamage < config.getInvulnerabilityTicks();
        
        // Debug logging
        if (config.isLogReplacementDamage()) {
            log.debug("{} invulnerability check: currentTick={}, lastDamage={}, ticksSince={}, invulnTicks={}, isInIFrames={}",
                    getEntityName(entity), currentTick, lastDamage, ticksSinceLastDamage, 
                    config.getInvulnerabilityTicks(), isInIFrames);
        }

        if (!isInIFrames) {
            wasReplacement.put(entityId, false);  // NOT a replacement
            lastProcessedTick.put(entityId, currentTick);
            return true;
        }

        // Inside i-frame window
        if (config.isDamageReplacementEnabled()) {
            Float previousDamage = lastDamageAmount.get(entityId);
            if (previousDamage == null) {
                wasReplacement.put(entityId, false);
                lastProcessedTick.put(entityId, currentTick);
                return false;
            }

            if (incomingDamage > previousDamage) {
                // REPLACEMENT HIT
                wasReplacement.put(entityId, true);  // THIS IS A REPLACEMENT
                lastProcessedTick.put(entityId, currentTick);
                if (config.isLogReplacementDamage()) {
                    log.debug("{} damage replacement: {} -> {} ({}/{} ticks)",
                            getEntityName(entity),
                            String.format("%.1f", previousDamage),
                            String.format("%.1f", incomingDamage),
                            ticksSinceLastDamage,
                            config.getInvulnerabilityTicks());
                }
                return true;
            } else {
                wasReplacement.put(entityId, false);
                lastProcessedTick.put(entityId, currentTick);
                if (config.isLogReplacementDamage()) {
                    log.debug("{} damage rejected (weaker): {} <= {} ({}/{} ticks)",
                            getEntityName(entity),
                            String.format("%.1f", incomingDamage),
                            String.format("%.1f", previousDamage),
                            ticksSinceLastDamage,
                            config.getInvulnerabilityTicks());
                }
                return false;
            }
        } else {
            wasReplacement.put(entityId, false);
            lastProcessedTick.put(entityId, currentTick);
            if (config.isLogReplacementDamage()) {
                log.debug("{} is invulnerable ({}/{} ticks)",
                        getEntityName(entity),
                        ticksSinceLastDamage,
                        config.getInvulnerabilityTicks());
            }
            return false;
        }
    }

    /**
     * Set an entity as invulnerable after taking damage
     */
    public void setInvulnerable(LivingEntity entity, float damageAmount) {
        lastDamageTick.put(entity.getUuid(), currentTick);
        lastDamageAmount.put(entity.getUuid(), damageAmount);

        if (config.getInvulnerabilityTicks() > 0 && config.isLogReplacementDamage()) {
            log.debug("{} now invulnerable for {} ticks (damage: {})",
                    getEntityName(entity),
                    config.getInvulnerabilityTicks(),
                    String.format("%.1f", damageAmount));
        }
    }
    
    /**
     * Update damage amount for replacement hits WITHOUT resetting invulnerability timer.
     * Used when a stronger hit lands during i-frames - we increase tracked damage but
     * don't give new i-frames (which would be exploitable).
     */
    public void updateDamageAmount(LivingEntity entity, float damageAmount) {
        lastDamageAmount.put(entity.getUuid(), damageAmount);
        if (config.isLogReplacementDamage()) {
            log.debug("{} damage amount updated to {} (no i-frame reset)",
                    getEntityName(entity),
                    String.format("%.1f", damageAmount));
        }
    }

    /**
     * Check if the last damage was a replacement hit
     */
    public boolean wasLastDamageReplacement(LivingEntity entity) {
        return wasReplacement.getOrDefault(entity.getUuid(), false);
    }

    /**
     * Get the last damage amount for an entity
     */
    public float getLastDamageAmount(LivingEntity entity) {
        return lastDamageAmount.getOrDefault(entity.getUuid(), 0f);
    }

    /**
     * Check if knockback should be applied for this entity
     */
    public boolean shouldApplyKnockback(LivingEntity entity) {
        boolean wasReplacementHit = wasLastDamageReplacement(entity);

        if (!wasReplacementHit) {
            return true;  // Normal hit, always apply knockback
        }

        // This was a replacement hit - check config
        return config.isKnockbackOnReplacement();
    }

    /**
     * Clean up tracking data for an entity
     */
    public void cleanup(LivingEntity entity) {
        UUID entityId = entity.getUuid();
        lastDamageTick.remove(entityId);
        lastDamageAmount.remove(entityId);
        wasReplacement.remove(entityId);
        lastProcessedTick.remove(entityId);
        if (entity instanceof Player player) {
            LogUtil.logCleanup("InvulnerabilityTracker", player.getUsername());
        }
    }

    /**
     * Clean up all tracking data
     */
    public void clearAll() {
        lastDamageTick.clear();
        lastDamageAmount.clear();
        wasReplacement.clear();
        lastProcessedTick.clear();
    }

    /**
     * Get the number of tracked entities
     */
    public int getTrackedEntities() {
        return lastDamageTick.size();
    }

    private String getEntityName(LivingEntity entity) {
        if (entity instanceof Player player) {
            return player.getUsername();
        }
        return entity.getClass().getSimpleName();
    }
}
